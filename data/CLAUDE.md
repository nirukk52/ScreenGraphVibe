## ScreenGraphVibe :data Module — Architecture & Guidelines

Purpose: Persistence layer using Drizzle ORM (PostgreSQL/Supabase). Provides a stable, typed data API to upstream modules without leaking infra concerns.

### Directory Layout (authoritative)
```text
data/
├─ src/
│  ├─ core/
│  │  └─ db/
│  │     ├─ client.ts                 # Create/export Drizzle instance (no side effects)
│  │     ├─ schema/
│  │     │  ├─ index.ts               # Barrel re-export of all feature schemas
│  │     │  └─ shared.ts              # Common columns/helpers (timestamps, ids, enums)
│  │     ├─ migrations-runner.ts      # Programmatic migration utilities (if needed)
│  │     └─ seed-runner.ts            # Programmatic seed utilities (compose feature seeds)
│  │
│  ├─ features/                        # One folder per feature (SRP, no cross-imports)
│  │  ├─ health/
│  │  │  ├─ health.schema.ts          # Drizzle tables for this feature only
│  │  │  ├─ health.repo.ts            # Repository functions (CRUD + transactions)
│  │  │  ├─ health.queries.ts         # Complex reads (joins, aggregates)
│  │  │  ├─ health.adapters.ts        # Mapping to/from external contracts
│  │  │  ├─ health.validators.ts      # Zod schemas for input validation
│  │  │  ├─ health.types.ts           # Re-export/generated types; no widening types
│  │  │  ├─ index.ts                  # Public API (barrel) for this feature
│  │  │  └─ __tests__/
│  │  │     ├─ unit/health.repo.test.ts
│  │  │     └─ integration/health.integration.test.ts
│  │  │
│  │  └─ app-launch-config/
│  │     ├─ app-launch-config.schema.ts
│  │     ├─ app-launch-config.repo.ts
│  │     ├─ app-launch-config.queries.ts
│  │     ├─ app-launch-config.adapters.ts
│  │     ├─ app-launch-config.validators.ts
│  │     ├─ app-launch-config.types.ts
│  │     ├─ index.ts
│  │     └─ __tests__/
│  │        ├─ unit/app-launch-config.repo.test.ts
│  │        └─ integration/app-launch-config.integration.test.ts
│  │
│  ├─ shared/
│  │  ├─ constants.ts                 # All string literals via enums/constants (Rule 3)
│  │  ├─ errors.ts                    # Typed error helpers
│  │  ├─ zod.ts                       # Zod helpers/patterns
│  │  └─ utils/
│  │     ├─ id.ts                     # ID generators/parsers
│  │     └─ pagination.ts             # Paging helpers (no DB coupling)
│  │
│  └─ index.ts                        # Public API surface of :data (exports features/*)
│
├─ db/
│  └─ migrations/                     # Drizzle migrations (never edit after creation)
│
├─ drizzle.config.ts                  # Points schema to src/core/db/schema/index.ts
├─ migrate.ts                         # CLI/programmable migration entry
├─ seed.ts                            # CLI/programmable seed entry (delegates to core)
├─ package.json
└─ vitest.config.ts
```

Notes
- `src/core/db/schema/index.ts` aggregates all feature schemas so Drizzle migrations see a single entrypoint.
- `src/core/db/client.ts` constructs the Drizzle client; no side effects beyond connection creation.
- No code in `data/db/migrations` is edited manually; generated by Drizzle.

### Public API Surface
- External consumers import from `@screengraph/data` (`src/index.ts`).
- Internals within this package should import via `src/core/*` and `src/features/<feature>/*` barrels.

### Testing Strategy
- Unit & integration tests live under each feature in `__tests__/unit` and `__tests__/integration`.
- E2E belongs to the top-level `:tests` package only.

### Migrations & Schema
- Add/modify fields in feature schemas → export via `src/core/db/schema/index.ts` → generate migration → run migration → update validators/adapters → add tests.

### Clean Imports
- Barrels only at boundaries: `src/index.ts`, `src/core/db/schema/index.ts`, `src/core/index.ts`, `src/features/**/index.ts`.
- All string literals come from `src/shared/constants.ts`.

### Additional Guidance
- Validation: Validate unknown input at feature boundaries (`*.validators.ts`). Repositories accept validated inputs only.
- Repositories vs. Queries: Keep repositories thin; place complex, read-only queries in `*.queries.ts`.
- Transactions: Make transaction boundaries explicit and small.
- Logging: Use shared logging module from `:logging` when needed; never log secrets.
- Errors: Use typed error helpers from `src/shared/errors.ts`.
- Performance: Avoid N+1, paginate by default, add indexes for hot paths.

---

### Clean Architecture Rules (v2)
1) Boundaries & direction: `:ui → :backend → :data`. Inner layers never import outer layers. Ports (interfaces) defined by callers, implemented by callees.
2) Ports & adapters: Repository/service interfaces live with consumers; implementations live with providers. No infra types in domain-facing code.
3) Public API surfaces: Each module exposes a single barrel index; no deep imports. Feature barrels only at feature boundaries.
4) Feature isolation: No cross-feature imports. Share via `features/core` or `core` only. Features must be independently testable.
5) No side effects on import: Construct only; execute via explicit functions/CLIs. Migrations/seeds run from scripts.
6) Strict typing: No implicit any; no unsafe casts. Prefer local inference; exported/public APIs fully annotated.
7) Contracts over types: External-facing contracts live at boundaries; adapters map to internal schema/types. Never widen generated ORM types.
8) Validate at boundaries: All unknown input validated with Zod at module/feature boundaries. Repos accept validated types only.
9) Constants/enums SoT: All string literals from constants/enums. All union switches exhaustive.
10) Immutability: Do not mutate shared state; return new objects. Treat inputs as read-only.
11) Size & complexity: Files < 400 lines; functions < 50; max nesting depth 3; prefer helpers/early returns.
12) Dependency inversion: Business logic depends on interfaces, not implementations. Inject dependencies; don’t instantiate infra in domain logic.
13) Composition > inheritance: Prefer small composable units and pure functions. Avoid class hierarchies.
14) No circular deps: Enforce no cycles across/within modules.
15) Schema evolution: Update schema → generate migration → run migration → update adapters/validators → add tests.
16) DB layer discipline: Repositories thin; complex reads in `*.queries.ts`; explicit transactions with clear boundaries.
17) Logging/tracing: Use `:logging`. No `console.log`. Include correlation IDs. Never log secrets.
18) Errors as types: Prefer typed errors or Result/Either-like patterns at boundaries. Never swallow errors.
19) Observability: Add structured logs to critical paths; instrument query latency with thresholds.
20) Testing strategy: Unit + integration colocated per feature. E2E only in `:tests`. Every logic branch needs a test.
21) Deterministic tests: No test interdependence; isolate I/O; use containers/fixtures; avoid flakiness.
22) Clean imports: Use module aliases; barrels only at boundaries; avoid deep relative paths.
23) Documentation: File headers explain purpose, dependencies, public API. Record decisions in `DECISIONS.md`.
24) Security & config: Read env via config module; validate it; least-privilege DB; parameterized queries only.
25) Performance & data: Avoid N+1; paginate by default; index hot paths; measure and regression-test.

Last updated: 2025-10-08

