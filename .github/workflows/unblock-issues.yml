name: Unblock Dependent Issues

on:
  pull_request:
    types: [closed]
  issues:
    types: [closed]

permissions:
  issues: write
  pull-requests: read

jobs:
  unblock:
    if: github.event.pull_request.merged == true || github.event.issue.state == 'closed'
    runs-on: ubuntu-latest
    steps:
      - name: Unblock dependent issues using GraphQL
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SG_BOT_TOKEN }}
          script: |
            // Get closed issue numbers
            const closedIssues = [];
            
            if (context.payload.pull_request) {
              const prBody = context.payload.pull_request.body || '';
              const matches = [...prBody.matchAll(/(?:closes|resolves|fixes)\s+#(\d+)/gi)];
              closedIssues.push(...matches.map(m => parseInt(m[1])));
            } else if (context.payload.issue) {
              closedIssues.push(context.payload.issue.number);
            }
            
            console.log(`ðŸ” Closed issues: ${closedIssues.join(', ')}`);
            
            if (closedIssues.length === 0) {
              console.log('âš ï¸ No closed issues found');
              return;
            }
            
            // Use GraphQL to get ALL open issues with their native relationship data
            const query = `
              query($owner: String!, $repo: String!, $cursor: String) {
                repository(owner: $owner, name: $repo) {
                  issues(first: 100, after: $cursor, states: OPEN) {
                    pageInfo {
                      hasNextPage
                      endCursor
                    }
                    nodes {
                      number
                      title
                      url
                      assignees(first: 10) {
                        nodes {
                          login
                        }
                      }
                      labels(first: 10) {
                        nodes {
                          name
                        }
                      }
                      trackedInIssues(first: 50) {
                        nodes {
                          number
                          state
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            let hasNextPage = true;
            let cursor = null;
            let allOpenIssues = [];
            
            // Paginate through all open issues
            while (hasNextPage) {
              const result = await github.graphql(query, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                cursor
              });
              
              allOpenIssues.push(...result.repository.issues.nodes);
              hasNextPage = result.repository.issues.pageInfo.hasNextPage;
              cursor = result.repository.issues.pageInfo.endCursor;
            }
            
            console.log(`ðŸ“‹ Found ${allOpenIssues.length} open issues`);
            
            // Process each closed issue
            for (const closedNum of closedIssues) {
              console.log(`\nðŸ” Processing closed issue #${closedNum}`);
              
              // Find issues that are blocked by this closed issue
              for (const issue of allOpenIssues) {
                // trackedInIssues = issues that THIS issue is blocked by
                const blockers = issue.trackedInIssues.nodes || [];
                const blockerNumbers = blockers.map(b => b.number);
                
                if (!blockerNumbers.includes(closedNum)) continue;
                
                console.log(`ðŸ”— Issue #${issue.number} is blocked by #${closedNum}`);
                console.log(`   All blockers: ${blockerNumbers.join(', ')}`);
                
                // Check if ALL blockers are closed
                const allResolved = blockers.every(b => b.state === 'CLOSED');
                const stillBlocked = blockers.filter(b => b.state !== 'CLOSED');
                
                if (allResolved) {
                  console.log(`âœ… Issue #${issue.number} is now UNBLOCKED`);
                  
                  // Post comment
                  const assignees = issue.assignees.nodes.map(a => `@${a.login}`).join(' ');
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `âœ… **Unblocked!** All dependencies resolved (${blockerNumbers.map(n => `#${n}`).join(', ')}).\n\n${assignees || '@' + context.repo.owner} This issue is ready to work on.`
                  });
                  
                  // Update labels
                  const currentLabels = issue.labels.nodes.map(l => l.name);
                  const newLabels = currentLabels
                    .filter(l => l !== 'status: blocked')
                    .concat(currentLabels.includes('status: ready') ? [] : ['status: ready']);
                  
                  await github.rest.issues.setLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: newLabels
                  });
                  
                  console.log(`   Updated labels: ${newLabels.join(', ')}`);
                } else {
                  console.log(`â¸ï¸  Issue #${issue.number} still blocked by: ${stillBlocked.map(b => `#${b.number}`).join(', ')}`);
                  
                  // Post partial update
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `â¸ï¸ Partially unblocked: #${closedNum} resolved.\n\nStill waiting on: ${stillBlocked.map(b => `#${b.number}`).join(', ')}`
                  });
                }
              }
            }
            
            console.log('\nâœ… Dependency check complete');
